Write a python code that takes a number n as input from stdin, outputs a single element of a sequence as a string to stdout. Just output the n-th element in the sequence, not the whole sequence or anything other than the single sequence element. You will be graded by my running your code and comparing the results with a look-up table. If you use a look-up table for your code, you will not only fail the test. Hardcoding values that can be computed without hardcoding is considered to be using a look-up table. Use only the standard python library. No packages will be installed with pip or conda. Output your final code at the end of your response inside triple backticks like:
```
#your code goes here
```
The last part of your response that is inside triple backticks will be used as your response for the purposes of the test. The code will be stopped after a short period of time, so make it efficient if needed.

Here is some information on the sequence:
```
Name: Number of solutions to x^2 - x + 1 == 0 (mod n).
Comments: Number of elliptic points of order 3 for Gamma_0(n).

Equivalently, number of fixed points of Gamma_0(n) of type rho.

Values are 0 or a power of 2.

Shadow transform of central polygonal numbers A002061. - _Michel Marcus_, Jun 06 2013

Empirical: a(n) == A001615(n) (mod 3) for all natural numbers n. - _John M. Campbell_, Apr 01 2018

From _Jianing Song_, Jul 03 2018: (Start)

The comment above is true. Since both a(n) and A001615(n) are multiplicative we just have to verify that for prime powers. Note that A001615(p^e) = (p+1)*p^(e-1). For p == 1 (mod 3), p+1 == 2 (mod 3) so (p+1)*p^(e-1) == 2 (mod 3); for p == 2 (mod 3), p+1 is a multiple of 3 so (p+1)*p^(e-1) == 0 (mod 3). For p = 3, if e = 1 then p+1 == 1 (mod 3); if e > 1 then (p+1)*p^(e-1) == 0 (mod 3).

Equivalently, number of solutions to x^2 + x + 1 == 0 (mod n). (End)
```