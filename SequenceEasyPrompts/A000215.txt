Write a python code that takes a number n as input from stdin, outputs a single element of a sequence as a string to stdout. Just output the n-th element in the sequence, not the whole sequence or anything other than the single sequence element. You will be graded by my running your code and comparing the results with a look-up table. If you use a look-up table for your code, you will not only fail the test. Hardcoding values that can be computed without hardcoding is considered to be using a look-up table. Use only the standard python library. No packages will be installed with pip or conda. Output your final code at the end of your response inside triple backticks like:
```
#your code goes here
```
The last part of your response that is inside triple backticks will be used as your response for the purposes of the test. The code will be stopped after a short period of time, so make it efficient if needed.

Here is some information on the sequence:
```
Name: Fermat numbers: a(n) = 2^(2^n) + 1.
Comments: It is conjectured that just the first 5 numbers in this sequence are primes.

An infinite coprime sequence defined by recursion. - _Michael Somos_, Mar 14 2004

For n>0, Fermat numbers F(n) have digital roots 5 or 8 depending on whether n is even or odd (Koshy). - _Lekraj Beedassy_, Mar 17 2005

This is the special case k=2 of sequences with exact mutual k-residues. In general, a(1)=k+1 and a(n)=min{m | m>a(n-1), mod(m,a(i))=k, i=1,...,n-1}. k=1 gives Sylvester's sequence A000058. - _Seppo Mustonen_, Sep 04 2005

For n>1 final two digits of a(n) are periodically repeated with period 4: {17, 57, 37, 97}. - _Alexander Adamchuk_, Apr 07 2007

For 1 < k <= 2^n, a(A007814(k-1)) divides a(n) + 2^k. More generally, for any number k, let r = k mod 2^n and suppose r != 1, then a(A007814(r-1)) divides a(n) + 2^k. - _T. D. Noe_, Jul 12 2007

From _Daniel Forgues_, Jun 20 2011: (Start)

The Fermat numbers F_n are F_n(a,b) = a^(2^n) + b^(2^n) with a = 2 and b = 1.

For n >= 2, all factors of F_n = 2^(2^n) + 1 are of the form k*(2^(n+2)) + 1 (k >= 1).

The products of distinct Fermat numbers (in their binary representation, see A080176) give rows of Sierpiński's triangle (A006943). (End)

Let F(n) be a Fermat number. For n > 2, F(n) is prime if and only if 5^((F(n)-1)/4) == sqrt(F(n)-1) (mod F(n)). - _Arkadiusz Wesolowski_, Jul 16 2011

Conjecture: let the smallest prime factor of Fermat number F(n) be P(F(n)). If F(n) is composite, then P(F(n)) < 3*2^(2^n/2 - n - 2). - _Arkadiusz Wesolowski_, Aug 10 2012

The Fermat primes are not Brazilian numbers, so they belong to A220627, but the Fermat composites are Brazilian numbers so they belong to A220571. For a proof, see Proposition 3 page 36 on "Les nombres brésiliens" in Links. - _Bernard Schott_, Dec 29 2012

It appears that this sequence is generated by starting with a(0)=3 and following the rule "Write in binary and read in base 4".  For an example of "Write in binary and read in ternary", see A014118. - _John W. Layman_, Jul 30 2013

Conjecture: the numbers > 5 in this sequence, i.e., 2^2^k + 1 for k>1, are exactly the numbers n such that (n-1)^4-1 divides 2^(n-1)-1. - _M. F. Hasler_, Jul 24 2015
```